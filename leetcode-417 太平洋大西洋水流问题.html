<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<div>
  <!--  图的深度优先遍历   算法视频9-4 -->
  给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
  规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。 请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

  提示：

  输出坐标的顺序不重要
  m 和 n 都小于150
   
  示例：

  给定下面的 5x5 矩阵:

  太平洋 ~ ~ ~ ~ ~
  ~ 1 2 2 3 (5) *
  ~ 3 2 3 (4) (4) *
  ~ 2 4 (5) 3 1 *
  ~ (6) (7) 1 4 5 *
  ~ (5) 1 1 2 4 *
  * * * * * 大西洋

  返回:
  [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
</div>

<script>
  var pacificAtlantic = function (matrix) {
    if (!matrix || !matrix[0]) return []; //不存在或者不是二维矩阵
    //得到矩阵的行列
    const m = matrix.length; //行
    const n = matrix[0].length; //列
    //新建两个矩阵 记录坐标
    const flow1 = Array.from({length: m}, () => new Array(n).fill(false))  //记录流到太平洋的坐标
    //Array.from({length:m},()=>new Array(n).fill(false)) 这个方法构建m长度数组，第二个参数指定数组里的值，这里填充里一个长度是n的数组再fill填充false
    const flow2 = Array.from({length: m}, () => new Array(n).fill(false)) //记录流到大西洋的坐标
    // console.log(flow2,flow1)

    //深度优先遍历
    const dfs = (r, c, flow) => {
      flow[r][c] = true ; //遍历到的节点是可以流到某个大洋的
      //遍历r,c节点的相邻节点 上 下 左 右
      //forEach(([nr,nrc])=>{}) 错误在这里没写[]!!!
      [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]].forEach(([nr, nc]) => {
        if (
            //保证下一个节点在矩阵中
            nr >= 0 && nr < m &&
            nc >= 0 && nc < n &&
            //保证节点没有访问过 防止死循环
            !flow[nr][nc] &&
            // 逆向思考 保证逆流而上 下一个节点的值大于等于上一个节点的值
            matrix[nr][nc] >= matrix[r][c]
        ) {
          dfs(nr, nc, flow)
        }
      })
    };
    // console.log(flow1,flow2)

    //沿着海岸线逆流而上 最后找出flow1 flow2中相同坐标都为true 的点
    for (let r = 0; r < m; r+=1) { //从第一行到最后一行
      dfs(r, 0, flow1)   ;           //c=0 就是第一列
      dfs(r, n - 1, flow2)          //遍历出最后一列的格子进行dfs 由于流进大西洋所以传的是flow2
    }
    for (let c = 0; c < n; c+=1) {
      dfs(0, c, flow1); //第一行
      dfs(m - 1, c, flow2)  //最后一行
    }

    console.log(flow1)

    //搜集能流到两个大洋里的坐标 flow1记录逆流 ，flow2记录逆流 最后找到都是true的坐标
    const res = [];
    for (let r = 0; r < m; r++) {
      for (let c = 0; c < n; c++) {
        if (flow1[r][c] && flow2[r][c]) {
          // console.log([r,c])
          res.push([r, c])
        }
      }
    }
    console.log(res)
    return res
  };

  const matrix = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]
  pacificAtlantic(matrix)
</script>


</body>
</html>