<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//     请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

// 示例 1:
//
//     输入: "abcabcbb"
//     输出: 3
//     解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 示例 2:
//
//     输入: "bbbbb"
//     输出: 1
//     解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
// 示例 3:
//
//     输入: "pwwkew"
//     输出: 3
//     解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
//      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。





// 准备 2 个指针 i、j，i 指向窗口左边，j 指向右边。指针每次可以向前“滑动”一个位置，它们之间的区域就是“窗口”。
//
// 整体流程如下：
//
// 准备哈希表 map。key 是 char，value 是 boolean，代表字符 char 是否出现在滑动窗口内
// i 和 j 初始化为 0，结果 ans 初始化为 0
// 检查s[j]是否出现过：
// 没有出现过，扩大窗口：记录s[j]，指针 j 向右滑动一格，更新 ans
// 出现过，缩小窗口：指针 i 向右移动一格，map[s[i]]更新为 false
// 如果 i 和 j 没有越界，回到 step3，否则返回 ans

//由于整个过程就是“推着”滑动窗口从左到右，时间复杂度是O(N)O(N)，空间复杂度是O(N)O(N)。


    var lengthOfLongestSubstring = function(s) {
        const len = s.length;
        const map = {};                 // 如果char重复，那么缩小滑动窗口，并更新对应的map
        let i = 0 , j=0, ans = 0;
        while (i<len && j<len){
            if(!map[s[j]]){
                ans = Math.max(j-i+1,ans);
                map[s[j]] = true;
                ++j;
            }else{
                // 如果char重复，那么缩小滑动窗口，并更新对应的map
                map[s[j]] = false
                ++i;
            }
        }
        return ans;

    }



// 在解法 1 的流程中的第 3 步，如果s[j]出现在滑动窗口内，采用的做法是左边逐步缩小滑动窗口。事实上，不需要逐步缩小。
// 假设滑动窗口内和s[j]相同字符下标是 j'，那么直接跳过[i, j'] 范围即可。
//
// 为了做到“跳动优化”，需要改造一下对哈希表 map 的用法：key 还是 char；value 变为 int，记录 char 对应的下标。
//
// 整体代码实现如下：

// 声明
//
// var map = new Map();
// 设值
//
// map.set("key","value");
// 取值
//
// map.get("key");
// 判断key是否存在
//
// map.has("key");
// 删除key
//
// map.delete("key");

var lengthOfLongestSubstring = function(s) {
    const length = s.length;
    const map = new Map();
    let i = 0,
        j = 0;
    let ans = 0;
    while (i < length && j < length) {
        // 容易理解：检查s[j]是否出现过，并且s[j]重复的字符是否在当前的滑动窗口中
        if (map.has(s[j]) && map.get(s[j]) >= i) {
            i = map.get(s[j]) + 1;
        }
        ans = Math.max(j - i + 1, ans);
        map.set(s[j], j);
        ++j;
    }
    return ans;
};


</script>


</body>
</html>